#0719
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.LOC
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM EMP E, DEPT D 
WHERE E.DEPTNO = D.DEPTNO AND E.SAL > 2000
ORDER BY D.DEPTNO, EMPNO;

SELECT D.DEPTNO, D.DNAME, TRUNC(AVG(E.SAL)) AVG_SAL, 
        MAX(E.SAL) MAX_SAL, MIN(E.SAL) MIN_SAL, COUNT(*) CNT
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

#급여 범위 지정 조건식으로 조인
SELECT * FROM SALGRADE;
SELECT * FROM EMP;

#비등가 JOIN
SELECT * FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

#자체 JOIN
SELECT * FROM EMP E, EMP C
WHERE E.MGR = C.EMPNO;

#8-8
SELECT E1.EMPNO, E1.ENAME, E1.MGR, 
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.MGR;

#외부조인 OUTTER JOIN
SELECT * FROM EMP;
SELECT COUNT(*) FROM EMP;
SELECT * FROM EMP WHERE ENAME = 'KING';

#일반적 등가 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

#LEFT OUTTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

#RIGHT OUTTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

#ANSI 표준
#SQL-99
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

#234 JOIN ~ ON
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       D.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO=D.DEPTNO)
ORDER BY E.DEPTNO, EMPNO;

#8-14 LEFT OUTTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#8-15 RIGHT OUTER JOIN 으로 위 쿼리
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#3-1번
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E, DEPT D WHERE D.DEPTNO=E.DEPTNO(+)
ORDER BY D.DEPTNO, E.ENAME;
#3-2
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E RIGHT OUTER JOIN DEPT D ON (D.DEPTNO=E.DEPTNO)
ORDER BY D.DEPTNO, E.ENAME;
#4
SELECT * FROM EMP;
SELECT D.DEPTNO, D.DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO DEPTNO_1,
        S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO MGR_EMPNO, E2.ENAME MGR_NAME
FROM EMP E1, DEPT D, SALGRADE S, EMP E2
WHERE E1.DEPTNO(+) = D.DEPTNO
    AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
    AND E1.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E1.EMPNO;

#ANSI SQL-99
SELECT D.DEPTNO, D.DNAME, E1.EMPNO, E1.ENAME,
       E1.MGR, E1.SAL, E1.DEPTNO, S.LOSAL,
       S.HISAL, S.GRADE
FROM EMP E1 RIGHT OUTER JOIN DEPT D ON (E1.DEPTNO = D.DEPTNO)
           LEFT OUTER JOIN SALGRADE S ON (E1.SAL BETWEEN S.LOSAL AND S.HISAL)
           LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E1.EMPNO;

#SUB QUERY
#사원이름 'JONES'인 급여 출력
SELECT SAL FROM EMP
WHERE ENAME = 'JONES';

#급여가 2975보다 높은 사원 정보 출력
SELECT * FROM EMP
WHERE SAL > 2975;

#급여가 'JONES'보다 높은 사원의 정보 출력
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');

#'KING'보다 급여 많은 사람
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'KING');

#EMP 사원 정보 중 사원 이름 ALLEN 추가수당보다 많이 받는 사원 정보
SELECT * FROM EMP
WHERE COMM > (SELECT COMM FROM EMP
               WHERE ENAME = 'ALLEN');
               
#9-4 서브쿼리 결과 값 날짜형
#'ALLEN'보다 입사일 빠른 직원
SELECT * FROM EMP
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'TURNER');

#9-5 JOIN 구문 SUBQUERY 동작할까
#평균급여보다 많이 받는 직원 정보
SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND D.DEPTNO = 20 AND E.SAL > (SELECT AVG(SAL) FROM EMP);

#다중행 연산자 P249
# IN 메인쿼리 데이터 서브쿼리 결과 중 하나라도 일치 데이터 존재 TRUE
# ANY, SOME 메인쿼리 조건식 만족 서브쿼리 결과 하나 이상 TRUE
# ALL 메인쿼리 조건식 서브쿼리 결과 모두 만족 TRUE
# EXISTS 

#IN 연산
SELECT * FROM EMP
WHERE DEPTNO IN (20, 30);

#각 부서별 최고급여 동일급여 사원정보 출력
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMP
WHERE SAL IN (SELECT MAX(SAL) FROM EMP 
              GROUP BY DEPTNO)
ORDER BY DEPTNO;

#ANY
SELECT * FROM EMP
WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP 
              GROUP BY DEPTNO)
ORDER BY DEPTNO;

#SOME
SELECT * FROM EMP
WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP 
              GROUP BY DEPTNO)
ORDER BY DEPTNO;

#ANY 30번 부서 사원들의 최대 급여보다 적은 급여 받는 사원 정보
SELECT * FROM EMP WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO=30);
SELECT * FROM EMP WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);

#9-14 ALL
# 30번 부서 사원들의 최소 급여보다 더 적은 급여
SELECT SAL FROM EMP WHERE DEPTNO=30;
SELECT * FROM EMP WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO=30);

SELECT * FROM EMP WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO=30);

SELECT * FROM EMP
WHERE EXISTS(SELECT DNAME FROM DEPT WHERE DEPTNO=10);

#없는 부서 50
SELECT * FROM EMP
WHERE EXISTS(SELECT DNAME FROM DEPT WHERE DEPTNO=50);

#비교할 열이 여러개인 다중열 서브쿼리
SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO;

#시험나옴!!!
SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

#1 'ALLEN'과 같은 직책 사원 정보 부서 정보
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO AND
                         E.JOB = (SELECT JOB FROM EMP WHERE ENAME='ALLEN')
ORDER BY E.ENAME;

SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
WHERE E.JOB = (SELECT JOB FROM EMP WHERE ENAME='ALLEN')
ORDER BY E.ENAME;
SELECT * FROM EMP;

#2 전체 사원 평균 급여보다 높은 급여 사원, 부서, 급여 등급 정보
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S 
WHERE E.DEPTNO = D.DEPTNO AND E.SAL BETWEEN S.LOSAL AND S.HISAL 
      AND E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, EMPNO;

SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
           JOIN SALGRADE S ON (E.SAL BETWEEN S.LOSAL AND S.HISAL) 
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY E.SAL DESC, EMPNO;

#DEPT 테이블 복사
CREATE TABLE DEPT_TEMP
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP;

#데이터 추가
#50번 부서 'DATABASE', 'SEOUL'
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC) VALUES(50, 'DATABASE', 'SEOUL');
INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC) VALUES(60, 'NETWORK', 'BUSAN');
INSERT INTO DEPT_TEMP VALUES (70, 'NETWORK2', 'ANDONG');

#NULL 입력가능?
INSERT INTO DEPT_TEMP(DEPTNO, LOC) VALUES(90, 'INCHEON');
INSERT INTO DEPT_TEMP(DEPTNO, DNAME, LOC) VALUES(80, 'MOBILE', '');

CREATE TABLE EMP_TEMP
AS SELECT * FROM EMP
WHERE 1 <> 1;

SELECT * FROM EMP_TEMP;

DELETE FROM EMP_TEMP;

#날짜 데이터 입력
INSERT INTO EMP_TEMP
VALUES (9999, '홍길동', 'PRESIDENT', NULL, '2001-01-01', 5000, 1000, 10);

INSERT INTO EMP_TEMP
VALUES (9999, '성춘향', 'PRESIDENT', NULL, TO_DATE('07/01/2001', 'DD/MM/YYYY'), 5000, 1000, 10);

INSERT INTO EMP_TEMP
VALUES (7777, '성춘향', 'PRESIDENT', NULL, SYSDATE, 5000, 1000, 10);
SELECT * FROM EMP_TEMP;

#UPDATE 
CREATE TABLE DEPT_TEMP2
AS SELECT * FROM DEPT;

SELECT * FROM DEPT_TEMP2;
COMMIT;

UPDATE DEPT_TEMP2 SET LOC = 'SEOUL';
ROLLBACK;

#DELETE
DELETE FROM DEPT_TEMP2 WHERE DEPTNO=40;
DELETE FROM DEPT_TEMP2 WHERE LOC='DALLAS';
